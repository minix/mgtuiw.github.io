---
layout: post
title: "文件"
---

linux文件由两部分组成：`inode`和`block`

当使用`file := os.Open("/path/to/file")`,就是打开/path/to/file这个文件的inode和block内容

`fileInfo := file.Stat`是将file的inode内容读取到fileInfo变量，inode包含了文件属性，如文件名，文件大小，指向哪些块等等信息

`file.Read`是将file所在的block的内容读出来

<!--more-->
###文件IO和标准IO###

**文件IO**:文件IO被称为不带缓存的IO(unbuffered I/O).不带缓存指的是每个read, write都调用内核中的一个系统调用，也就是一般的低级IO，操作系统提供的基本IO服务，与OS绑定，特定于unix/linux平台。

**标准IO**:标准IO是ANSI C建立的一个标准IO模型,是一个标准函数包和stdio.h头文件中的定义,具有一定的可移植性.标准IO库处理很多细节.例如缓存分配,以优化长度执行IO等.标准的IO提供了三种类型的缓存.

- 全缓存: 当填满标准IO缓存后才进行实际的IO操作

- 行缓存: 当输入或输出中遇到新行符时,标准IO库执行IO操作

- 不带缓存: stderr就是了

###文件IO和标准IO的区别###

####文件IO####
**文件IO**称为低级磁盘IO,遵循POSIX相关标准.任何兼容POSIX标准的操作系统上都支持文件IO

####标准IO####
**标准IO**称为高级磁盘IO, 遵循ANSI C相关标准.只要开发环境中有标准IO库就可以使用.(Linux中使用GLIBC,它是标准C库的超集.不仅包含ANSI C中定义的函数,还包括POSIX标准中定义的函数.因此,Linux既可以使用标准IO,也可以使用文件IO)

文件IO在读写文件时,每次操作都会执行相关系统调用.这样处理的好处是直接读写实际文件,坏处是频繁的系统调用会增加系统开销.标准IO可以看成是文件IO的基础上封装了缓冲机制,先读写缓冲区,必要时再访问实际文件,从而减少了系统调用的次数

文件IO中用文件描述符表现一个打开的文件,可以访问不同类型的文件,如普通文件,设备文件和管道文件等等.而标准IO使用FILE(流)表示一个打开的文件,通常只能用来访问普通文件


